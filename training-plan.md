# 4-WEEK PROBLEM-SOLVING, DATA STRUCTURES, & ALGORITHM TRAINING PLAN
* 2-3 problems per day (i.e. 1-2 hours)
* Only review solutions AFTER self-attempt
* Note down common patterns
* For mock interviews: 2 easy (15 mins/p) > 2 medium (30 mins/p) > 1 hard (50 mins)

## Week 1 - Foundations: Array, Hashing, Two Pointers, Prefix Sums
Goal: Learn to identify when a problem can be solved in O(N) using scanning, hashing, or pointer techniques.

### Key Patterns
* When to use a hash map instead of nested loops
* Prefix sums for range/difference problems
* Two pointers for scanning sorted arrays or opposite ends
* Sliding window for subarray constraints

### Problem Sets
Arrays / Hashing:
- [x] Two Sum
- [x] Contains Duplicate
- [x] First Unique Character
- [x] Valid Anagram
- [ ] Majority Element
- [x] Odd Occurrences in Array (Codility)
- [x] Passing Cars (Codility)
- [x] Tape Equilibrium (Codility)

Prefix Sums:
- [ ] Subarray Sum Equals K
- [ ] Minimum Size Subarray Sum
- [ ] Range Sum Query (immutable)

Two-Pointer / Sliding Window:
- [ ] Move Zeroes
- [ ] Remove Duplicates from Sorted Array
- [ ] Longest Substring Without Repeating Characters
- [ ] Number of Subarrays with Product < K

## Week 2 - Intermediate: Sorting, Greedy, Stacks, Queues
Goal: Recognizing structural patterns that point to optimal O(N log N) or O(N) solutions.

### Key Patterns
* Greedy decision-making
* Monotonic stacks
* When sorting simplifies the problem
* Recognizing substructure and constraints

### Problem Sets
Sorting + Greedy:
- [ ] Non-overlapping Intervals
- [ ] Merge Intervals
- [ ] Maximum Product of Three
- [ ] Meeting Rooms
- [ ] Assign Cookies
- [ ] Minimum Number of Arrows to Burst Balloons

Stacks:
- [ ] Valid Parentheses
- [ ] Min Stack
- [ ] Daily Temperatures
- [ ] Stone Wall (Codility)

Queues / Deque:
- [ ] Sliding Window Maximum
- [ ] Recent Counter

## Week 3 - Advanced: Trees, Graphs, Heaps
Goal: Build intuition around hierarchical structures and optimal retrieval (heap).

### Key Patterns
* BFS vs DFS
* When to use a queue vs recursion
* When heaps (priority queues) simplify ordering problems
* Graph traversal patterns: visiting once, avoiding cycles

### Problem Sets
Trees (DFS & BFS):
- [ ] Invert Binary Tree
- [ ] Maximum Depth
- [ ] Balanced Binary Tree
- [ ] Binary Tree Level Order Traversal
- [ ] Lowest Common Ancestor

Graphs:
- [ ] Number of Islands
- [ ] Clone Graph
- [ ] Course Schedule (topological sorting)
- [ ] Rotting Oranges
- [ ] Shortest Path in Binary Matrix (BFS)

Heaps / Priority Queues: 
- [ ] K Closest Points to Origin
- [ ] Merge K Sorted Lists
- [ ] Last Stone Weight
- [ ] Meeting Rooms II (min heap)

## Week 4 - Mastery: Dynamic Programming + Combined Techniques
Goal: Strengthen pattern recognition for DP and multi-step problems.

### Key Patterns
* DP on sequences (fib, climbing stairs)
* Subset / knapsack style DP
* Optimizing with rolling arrays
* When greedy fails → DP usually works

### Problem Sets
1D / Sequence DP:
- [ ] Climbing Stairs
- [ ] House Robber
- [ ] Maximum Subarray (Kadane’s algorithm)
- [ ] Decode Ways
- [ ] Jump Game

String DP:
- [ ] Longest Common Subsequence
- [ ] Edit Distance
- [ ] Longest Palindromic Substring

Grid DP:
- [ ] Unique Paths
- [ ] Minimum Path Sum